local protoc = require("pb.protoc")
local unfold = require("unfold")
local sio = require("sio")
local utils = require("utils")

local function get_nodes(l)
	local nodes = {}
	for _,v in ipairs(l) do
		nodes[v] = gui.get_node(v)
	end
	return nodes
end

-- Adapted from https://github.com/subsoap/defglot/blob/master/defglot/defglot.lua#L67
local function autofit_text(node)
	local text_metrics = gui.get_text_metrics_from_node(node)
	local scale = math.min(1, gui.get_size(node).x / text_metrics.width)
	gui.set_scale(node, vmath.vector3(scale, scale, scale))
end

-- https://github.com/andsve/dirtylarry/blob/master/dirtylarry/dirtylarry.lua#L22
local function is_enabled(node)
	local parent = gui.get_parent(node)
	if parent then
		return is_enabled(parent)
	end
	return gui.is_enabled(node)
end

-- https://github.com/andsve/dirtylarry/blob/master/dirtylarry/dirtylarry.lua#L38
local function hit_test(node, action_id, action)
	if not is_enabled(node) then
		return false
	end

	local hit = gui.pick_node(node, action.x, action.y)
	local touch = (action_id == hash("touch"))
	return touch and hit
end

local function hex_to_v4(h)
	h = string.match(h, "%x%x%x%x%x%x")
	local r = tonumber(h:sub(1,2), 16)/255
	local g = tonumber(h:sub(3,4), 16)/255
	local b = tonumber(h:sub(5,6), 16)/255
	return vmath.vector4(r, g, b, 1)
end

local function switch_page(self, to)
	if self.current_page == to then return end -- Already the active page, do nothing
	for i,v in pairs(self.pages) do
		if i == to then
			gui.set_enabled(v, true)
			gui.set_enabled(gui.get_node(i .. "_tab_light"), true)
		else
			gui.set_enabled(v, false)
			gui.set_enabled(gui.get_node(i .. "_tab_light"), false)
			gui.set_color(gui.get_node(i .. "_tab"), hex_to_v4("#808080"))
		end
	end
	self.current_page = to
end

local function button(self, id, normal_color, highlight_color, action_id, action, on_click)
	local node = gui.get_node(id)
	if hit_test(node, action_id, action) then
		if action.pressed then
			if gui.pick_node(node, action.x, action.y) then
				on_click(self)
			end
		end
	elseif action_id == nil then
		if gui.pick_node(node, action.x, action.y) then
			gui.set_color(node, hex_to_v4(highlight_color))
		else
			gui.set_color(node, hex_to_v4(normal_color))
		end
	end
end

local function tab(self, page, action_id, action)
	local tab_id = page .. "_tab"
	local text_color = (self.current_page == page and "#ffffff" or "#808080")
	button(self, tab_id, text_color, "#ffffff", action_id, action, function()
		switch_page(self, page)
	end)
end

local function set_status(node, text, error)
	if error then
		gui.set_color(node, vmath.vector4(0.86, 0.17, 0, 1))
	else
		gui.set_color(node, vmath.vector4(1, 1, 1, 1))
	end
	gui.set_text(node, text)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "clear_color", {color = vmath.vector4(0.07, 0.07, 0.07, 1)})

	self.nodes = get_nodes({"bundle_path_text", "output_path_text", "export_status", "import_input_path_text", "import_status"})

	self.pages = {
		setup = gui.get_node("setup"),
		export = gui.get_node("export"),
		import = gui.get_node("import")
	}

	switch_page(self, "setup")
end

function on_input(self, action_id, action)
	-- Setup --------------------------
	tab(self, "setup", action_id, action)
	
	button(self, "select_bundle", "#2b2b2b", "#363636", action_id, action, function(self)
		local code, path = diags.open_folder()
		if code == 1 then
			self.bundle_path = path
			gui.set_text(self.nodes.bundle_path_text, path)
			autofit_text(self.nodes.bundle_path_text)
		end
	end)

	-- Export -------------------------
	tab(self, "export", action_id, action)
	
	button(self, "select_output", "#2b2b2b", "#363636", action_id, action, function(self)
		local code, path = diags.open_folder()
		if code == 1 then
			self.output_path = path
			gui.set_text(self.nodes.output_path_text, path)
			autofit_text(self.nodes.output_path_text)
		end
	end)
	button(self, "export_button", "#0091ea", "#00b0ff", action_id, action, function(self)
		if not self.bundle_path then
			set_status(self.nodes.export_status, "You have to select a bundle folder!", true)
			return
		elseif not self.output_path then
			set_status(self.nodes.export_status, "You have to select and output folder!", true)
			return
		end
		set_status(self.nodes.export_status, "", false)

		self.bundle_path = utils.to_unix(self.bundle_path)
		self.output_path = utils.to_unix(self.output_path)

		-- Remove ending slash if it exists
		if self.bundle_path:sub(-1,-1) == "/" then
			self.bundle_path = self.bundle_path:sub(1,-2)
		end
		if self.output_path:sub(-1,-1) == "/" then
			self.output_path = self.output_path:sub(1,-2)
		end

		print("Bundle path: " .. utils.to_platform(self.bundle_path))
		print("Output path: " .. utils.to_platform(self.output_path))

		if not file_exists(self.bundle_path .. "/game.arci") or
		not file_exists(self.bundle_path  .. "/game.arcd") or
		not file_exists(self.bundle_path .. "/game.dmanifest") then
			set_status(self.nodes.export_status, "Not a valid bundle folder!", true)
			return
		end

		local arc_data = sio.read(self.bundle_path .. "/game.arcd")
		local index = unfold.read_index(self.bundle_path .. "/game.arci")
		local manifest = unfold.read_manifest(self.bundle_path .. "/game.dmanifest")
		manifest = unfold.convert_hashes(manifest)
		local entries = unfold.get_entries(arc_data, index, manifest)

		set_status(self.nodes.export_status, "Writing to " .. utils.to_platform(self.output_path) .. "...", false)
		for i,v in ipairs(entries) do
			if v.url then
				local url = utils.to_platform(self.output_path .. v.url)
				mkdir(unfold.enclosing_folder(url))
				sio.write(url, v.data)
			end
		end

		set_status(self.nodes.export_status, "Done! Written to " .. utils.to_platform(self.output_path), false)
	end)

	-- Import -------------------------
	tab(self, "import", action_id, action)

	button(self, "import_select_input", "#2b2b2b", "#363636", action_id, action, function(self)
		local code, path = diags.open_folder()
		if code == 1 then
			self.input_path = path
			gui.set_text(self.nodes.import_input_path_text, path)
			autofit_text(self.nodes.import_input_path_text)
		end
	end)
end